\hypertarget{classoscar_1_1Transport}{}\doxysection{Transport$<$ Self $>$}
\label{classoscar_1_1Transport}\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}}


{\ttfamily \#include \char`\"{}core/\+Transport.\+hpp\char`\"{}}



Collaboration diagram for Transport$<$ Self $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=224pt]{classoscar_1_1Transport__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}} = typename \mbox{\hyperlink{structoscar_1_1TransportMeta}{Transport\+Meta}}$<$ Self $>$\+::\mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}}
\item 
using \mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}} = std\+::function$<$ void()$>$
\item 
using \mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}} = std\+::function$<$ std\+::size\+\_\+t(\mbox{\hyperlink{Type_8hpp_a8acb43b3e680d8f2df1b66ab53eb20af}{Buffer}}$<$ \mbox{\hyperlink{classoscar_1_1Transport_a01c5fb279d6b80ebed829be7a804dde2}{BUFFER\+\_\+\+SIZE}} $>$ \&buffer)$>$
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}} \mbox{\hyperlink{classoscar_1_1Transport_a89734c342cac0f428c4653c656821636}{allocate\+Address}} ()=0
\item 
virtual void \mbox{\hyperlink{classoscar_1_1Transport_a76f67960f0c55270475b5995e9ecb9e8}{register\+Receiver}} (\mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&receiver)=0
\item 
virtual void \mbox{\hyperlink{classoscar_1_1Transport_a25108bca10e81b195a42266f2c1a5bd2}{register\+Multicast\+Receiver}} (\mbox{\hyperlink{classoscar_1_1TransportMulticastReceiver}{Transport\+Multicast\+Receiver}}$<$ Self $>$ \&receiver)=0
\item 
virtual void \mbox{\hyperlink{classoscar_1_1Transport_a4bb5fc411813a63a08bcd0725682a0b7}{schedule\+Timeout}} (std\+::chrono\+::microseconds delay, \mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}} callback)=0
\item 
virtual void \mbox{\hyperlink{classoscar_1_1Transport_abdfe4e9d8c5c75d92a6e0d4537c7a8bc}{schedule\+Sequential}} (\mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}} callback)
\item 
virtual void \mbox{\hyperlink{classoscar_1_1Transport_a3cb0a793c8df60862c9506aed5f7880d}{schedule\+Concurrent}} (\mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}} callback)=0
\item 
virtual int \mbox{\hyperlink{classoscar_1_1Transport_a80a1bffd0639aedd276a53be28b9fde3}{get\+Concurrent\+Id}} () const =0
\item 
virtual void \mbox{\hyperlink{classoscar_1_1Transport_a428461e07c001528d167a143d0aaed79}{send\+Message}} (const \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&sender, const \mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}} \&dest, \mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}} write)=0
\item 
\mbox{\Hypertarget{classoscar_1_1Transport_a1017301869d80c4bd267ab777da7fbd7}\label{classoscar_1_1Transport_a1017301869d80c4bd267ab777da7fbd7}} 
void {\bfseries send\+Message\+To\+Replica} (const \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&sender, Replica\+Id replica\+\_\+id, \mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}} write)
\item 
virtual void \mbox{\hyperlink{classoscar_1_1Transport_a266d9f88b4ba748bdb8fd8c3640791c3}{send\+Message\+To\+All}} (const \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&sender, \mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}} write)
\item 
\mbox{\Hypertarget{classoscar_1_1Transport_aa978c50d0d83ec0a61f80e1b5f09071c}\label{classoscar_1_1Transport_aa978c50d0d83ec0a61f80e1b5f09071c}} 
virtual void {\bfseries send\+Message\+To\+Multicast} (const \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&sender, \mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}} write)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const \mbox{\hyperlink{structoscar_1_1Config}{Config}}$<$ Self $>$ \& \mbox{\hyperlink{classoscar_1_1Transport_a7d3a3a71db9e796d43f4001b419e83c4}{config}}
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static constexpr std\+::size\+\_\+t \mbox{\hyperlink{classoscar_1_1Transport_a01c5fb279d6b80ebed829be7a804dde2}{BUFFER\+\_\+\+SIZE}} = \mbox{\hyperlink{structoscar_1_1TransportMeta}{Transport\+Meta}}$<$Self$>$\+::BUFFER\+\_\+\+SIZE
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classoscar_1_1Transport_ac9a29eaa89638d455a7b6eeb2e0001c9}{Transport}} (const \mbox{\hyperlink{structoscar_1_1Config}{Config}}$<$ Self $>$ \&\mbox{\hyperlink{classoscar_1_1Transport_a7d3a3a71db9e796d43f4001b419e83c4}{config}})
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Self$>$\newline
class oscar\+::\+Transport$<$ Self $>$}

General supporting runtime for {\ttfamily \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}}, the sending half of the actor model (and more).

The base class takes curiously recurring template pattern. The subclass {\ttfamily \mbox{\hyperlink{classoscar_1_1Transport}{Transport}}} is passed as template argument to {\ttfamily \mbox{\hyperlink{classoscar_1_1Transport}{Transport}}}, as well as {\ttfamily \mbox{\hyperlink{structoscar_1_1Config}{Config}}}, {\ttfamily \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}}, etc.

Besides of all interfaces defined here, a {\ttfamily \mbox{\hyperlink{classoscar_1_1Transport}{Transport}}} implementation probably wants to provide a {\ttfamily run} method to start main loop. 

Definition at line 42 of file Transport.\+hpp.



\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}\label{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!Address@{Address}}
\index{Address@{Address}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{Address}{Address}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}} =  typename \mbox{\hyperlink{structoscar_1_1TransportMeta}{Transport\+Meta}}$<$Self$>$\+::\mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}}}

Value-\/semantic address type. Possible choices include plain string, {\ttfamily socketaddr\+\_\+in}, or more customized ones. 

Definition at line 54 of file Transport.\+hpp.

\mbox{\Hypertarget{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}\label{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!Callback@{Callback}}
\index{Callback@{Callback}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{Callback}{Callback}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}} =  std\+::function$<$void()$>$}

General task closure. Receiver can keep things inside it alive between working steps. 

Definition at line 75 of file Transport.\+hpp.

\mbox{\Hypertarget{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}\label{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!Write@{Write}}
\index{Write@{Write}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{Write}{Write}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}} =  std\+::function$<$std\+::size\+\_\+t(\mbox{\hyperlink{Type_8hpp_a8acb43b3e680d8f2df1b66ab53eb20af}{Buffer}}$<$\mbox{\hyperlink{classoscar_1_1Transport_a01c5fb279d6b80ebed829be7a804dde2}{BUFFER\+\_\+\+SIZE}}$>$ \&buffer)$>$}

Argument for {\ttfamily send\+Message$\ast$} methods. The lambda should in-\/place serialize message into {\ttfamily buffer}, and return message length. The returned value must not exceed {\ttfamily BUFFER\+\_\+\+SIZE}. 

Definition at line 123 of file Transport.\+hpp.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classoscar_1_1Transport_ac9a29eaa89638d455a7b6eeb2e0001c9}\label{classoscar_1_1Transport_ac9a29eaa89638d455a7b6eeb2e0001c9}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!Transport@{Transport}}
\index{Transport@{Transport}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{Transport()}{Transport()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classoscar_1_1Transport}{Transport}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structoscar_1_1Config}{Config}}$<$ Self $>$ \&}]{config }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

Construct base class with global configuration. 

Definition at line 47 of file Transport.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{47 : \mbox{\hyperlink{classoscar_1_1Transport_a7d3a3a71db9e796d43f4001b419e83c4}{config}}(\mbox{\hyperlink{classoscar_1_1Transport_a7d3a3a71db9e796d43f4001b419e83c4}{config}}) \{\}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classoscar_1_1Transport_a89734c342cac0f428c4653c656821636}\label{classoscar_1_1Transport_a89734c342cac0f428c4653c656821636}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!allocateAddress@{allocateAddress}}
\index{allocateAddress@{allocateAddress}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{allocateAddress()}{allocateAddress()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}} allocate\+Address (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Dynamically allocate free address, mainly for construct {\ttfamily \mbox{\hyperlink{classoscar_1_1Client}{Client}}}. \mbox{\Hypertarget{classoscar_1_1Transport_a76f67960f0c55270475b5995e9ecb9e8}\label{classoscar_1_1Transport_a76f67960f0c55270475b5995e9ecb9e8}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!registerReceiver@{registerReceiver}}
\index{registerReceiver@{registerReceiver}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{registerReceiver()}{registerReceiver()}}
{\footnotesize\ttfamily virtual void register\+Receiver (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&}]{receiver }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Register a receiver. The caller ensures that receiver\textquotesingle{}s reference will be valid as long as message get received on receiver\textquotesingle{}s address, which probably happens through the rest of {\ttfamily \mbox{\hyperlink{classoscar_1_1Transport}{Transport}}}\textquotesingle{}s lifetime. \mbox{\Hypertarget{classoscar_1_1Transport_a25108bca10e81b195a42266f2c1a5bd2}\label{classoscar_1_1Transport_a25108bca10e81b195a42266f2c1a5bd2}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!registerMulticastReceiver@{registerMulticastReceiver}}
\index{registerMulticastReceiver@{registerMulticastReceiver}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{registerMulticastReceiver()}{registerMulticastReceiver()}}
{\footnotesize\ttfamily virtual void register\+Multicast\+Receiver (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoscar_1_1TransportMulticastReceiver}{Transport\+Multicast\+Receiver}}$<$ Self $>$ \&}]{receiver }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Register a receiver that listens to multicast messages. \mbox{\hyperlink{classoscar_1_1Transport}{Transport}} implementation may require receiver to call {\ttfamily register\+Receiver} first. \mbox{\Hypertarget{classoscar_1_1Transport_a4bb5fc411813a63a08bcd0725682a0b7}\label{classoscar_1_1Transport_a4bb5fc411813a63a08bcd0725682a0b7}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!scheduleTimeout@{scheduleTimeout}}
\index{scheduleTimeout@{scheduleTimeout}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{scheduleTimeout()}{scheduleTimeout()}}
{\footnotesize\ttfamily virtual void schedule\+Timeout (\begin{DoxyParamCaption}\item[{std\+::chrono\+::microseconds}]{delay,  }\item[{\mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}}}]{callback }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Schedule a one-\/time timeout. {\ttfamily callback} will be called after {\ttfamily delay}, cannot be canceled.

Unlike receiving message, timeout is non-\/direction, i.\+e., does not have a {\ttfamily receiver}. The behavior depends on {\ttfamily callback}\textquotesingle{}s capturing.

Timeout\textquotesingle{}s {\ttfamily callback} is always executed sequentially. \mbox{\Hypertarget{classoscar_1_1Transport_abdfe4e9d8c5c75d92a6e0d4537c7a8bc}\label{classoscar_1_1Transport_abdfe4e9d8c5c75d92a6e0d4537c7a8bc}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!scheduleSequential@{scheduleSequential}}
\index{scheduleSequential@{scheduleSequential}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{scheduleSequential()}{scheduleSequential()}}
{\footnotesize\ttfamily virtual void schedule\+Sequential (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}}}]{callback }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Schedule a sequential task. Sequential task is promised to be executed one by one without concurrency, so different sequential tasks can share states without locking. However, it is not guaranteed that all sequential tasks will be executed by the same thread.

A default implementation is provided mainly for implying that timeout is sequential task by default, so there is no need for calling {\ttfamily schedule\+Sequential} inside timeout callback. 

Definition at line 95 of file Transport.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{96     \{}
\DoxyCodeLine{97         \mbox{\hyperlink{classoscar_1_1Transport_a4bb5fc411813a63a08bcd0725682a0b7}{scheduleTimeout}}(std::chrono::microseconds(0), callback);}
\DoxyCodeLine{98     \}}

\end{DoxyCode}
\mbox{\Hypertarget{classoscar_1_1Transport_a3cb0a793c8df60862c9506aed5f7880d}\label{classoscar_1_1Transport_a3cb0a793c8df60862c9506aed5f7880d}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!scheduleConcurrent@{scheduleConcurrent}}
\index{scheduleConcurrent@{scheduleConcurrent}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{scheduleConcurrent()}{scheduleConcurrent()}}
{\footnotesize\ttfamily virtual void schedule\+Concurrent (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classoscar_1_1Transport_a9f4d3f1692b57758c10763bea8a50a04}{Callback}}}]{callback }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Schedule a concurrent task. Multiple concurrent tasks may be executed with temporal overlapping, so they would better to be stateless. \mbox{\Hypertarget{classoscar_1_1Transport_a80a1bffd0639aedd276a53be28b9fde3}\label{classoscar_1_1Transport_a80a1bffd0639aedd276a53be28b9fde3}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!getConcurrentId@{getConcurrentId}}
\index{getConcurrentId@{getConcurrentId}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{getConcurrentId()}{getConcurrentId()}}
{\footnotesize\ttfamily virtual int get\+Concurrent\+Id (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Every concurrent task get assigned to a concurrent id, which can be queried by calling {\ttfamily get\+Concurrent\+Id} during execution. Concurrent id is unsigned and bounded.

\mbox{\hyperlink{classoscar_1_1Transport}{Transport}} implementation promise that all concurrent tasks that get assigned to the same concurrent id will be sequentially executed. So it is safe to reuse pre-\/allocated memory \char`\"{}slot\char`\"{} among those tasks.

\mbox{\hyperlink{classoscar_1_1Transport}{Transport}} may set concurrent id to {\ttfamily -\/1} for sequential tasks, but it is encouraged to determine sequential tasks by themselves. \mbox{\Hypertarget{classoscar_1_1Transport_a428461e07c001528d167a143d0aaed79}\label{classoscar_1_1Transport_a428461e07c001528d167a143d0aaed79}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!sendMessage@{sendMessage}}
\index{sendMessage@{sendMessage}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{sendMessage()}{sendMessage()}}
{\footnotesize\ttfamily virtual void send\+Message (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&}]{sender,  }\item[{const \mbox{\hyperlink{classoscar_1_1Transport_a1c8682bdba52d3903c24664c9574923d}{Address}} \&}]{dest,  }\item[{\mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}}}]{write }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Send a message. The first argument is probably {\ttfamily $\ast$this}.

\mbox{\hyperlink{classoscar_1_1Transport}{Transport}} implementation promise not to access {\ttfamily write} after this method return, so the closure can capture references with no worry. \mbox{\Hypertarget{classoscar_1_1Transport_a266d9f88b4ba748bdb8fd8c3640791c3}\label{classoscar_1_1Transport_a266d9f88b4ba748bdb8fd8c3640791c3}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!sendMessageToAll@{sendMessageToAll}}
\index{sendMessageToAll@{sendMessageToAll}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{sendMessageToAll()}{sendMessageToAll()}}
{\footnotesize\ttfamily virtual void send\+Message\+To\+All (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classoscar_1_1TransportReceiver}{Transport\+Receiver}}$<$ Self $>$ \&}]{sender,  }\item[{\mbox{\hyperlink{classoscar_1_1Transport_a1b95d6e95646af8502c81eb51ea1f232}{Write}}}]{write }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

The default implementation is mainly for illustration purpose. \mbox{\hyperlink{classoscar_1_1Transport}{Transport}} should provide a more efficient version that only serialize once. 

Definition at line 143 of file Transport.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{144     \{}
\DoxyCodeLine{145         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} address : \mbox{\hyperlink{classoscar_1_1Transport_a7d3a3a71db9e796d43f4001b419e83c4}{config}}.replica\_address\_list) \{}
\DoxyCodeLine{146             \textcolor{keywordflow}{if} (address != sender.address) \{}
\DoxyCodeLine{147                 \mbox{\hyperlink{classoscar_1_1Transport_a428461e07c001528d167a143d0aaed79}{sendMessage}}(sender, address, write);}
\DoxyCodeLine{148             \}}
\DoxyCodeLine{149         \}}
\DoxyCodeLine{150     \}}

\end{DoxyCode}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classoscar_1_1Transport_a7d3a3a71db9e796d43f4001b419e83c4}\label{classoscar_1_1Transport_a7d3a3a71db9e796d43f4001b419e83c4}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!config@{config}}
\index{config@{config}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{config}{config}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structoscar_1_1Config}{Config}}$<$Self$>$\& config}

Configuration for {\ttfamily \mbox{\hyperlink{classoscar_1_1Transport}{Transport}}} instance, along with all registered receivers. 

Definition at line 62 of file Transport.\+hpp.

\mbox{\Hypertarget{classoscar_1_1Transport_a01c5fb279d6b80ebed829be7a804dde2}\label{classoscar_1_1Transport_a01c5fb279d6b80ebed829be7a804dde2}} 
\index{Transport$<$ Self $>$@{Transport$<$ Self $>$}!BUFFER\_SIZE@{BUFFER\_SIZE}}
\index{BUFFER\_SIZE@{BUFFER\_SIZE}!Transport$<$ Self $>$@{Transport$<$ Self $>$}}
\doxysubsubsection{\texorpdfstring{BUFFER\_SIZE}{BUFFER\_SIZE}}
{\footnotesize\ttfamily constexpr std\+::size\+\_\+t BUFFER\+\_\+\+SIZE = \mbox{\hyperlink{structoscar_1_1TransportMeta}{Transport\+Meta}}$<$Self$>$\+::BUFFER\+\_\+\+SIZE\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

The size of buffer of tx message. May be helpful in assertion. 

Definition at line 118 of file Transport.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
core/Transport.\+hpp\end{DoxyCompactItemize}
