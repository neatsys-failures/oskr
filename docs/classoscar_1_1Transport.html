<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Oscar: Transport&lt; Self &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="override.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Oscar
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">High Performance Distributed</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classoscar_1_1Transport.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classoscar_1_1Transport-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Transport&lt; Self &gt;<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="Transport_8hpp_source.html">core/Transport.hpp</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for Transport&lt; Self &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classoscar_1_1Transport__coll__graph.png" border="0" usemap="#aTransport_3_01Self_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aTransport_3_01Self_01_4_coll__map" id="aTransport_3_01Self_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="5,100,197,129"/>
<area shape="rect" href="structoscar_1_1Config.html" title=" " alt="" coords="20,5,183,35"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c8682bdba52d3903c24664c9574923d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a> = typename <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt; Self &gt;::<a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a></td></tr>
<tr class="separator:a1c8682bdba52d3903c24664c9574923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4d3f1692b57758c10763bea8a50a04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a> = std::function&lt; void()&gt;</td></tr>
<tr class="separator:a9f4d3f1692b57758c10763bea8a50a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b95d6e95646af8502c81eb51ea1f232"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a> = std::function&lt; std::size_t(<a class="el" href="Type_8hpp.html#a8acb43b3e680d8f2df1b66ab53eb20af">Buffer</a>&lt; <a class="el" href="classoscar_1_1Transport.html#a01c5fb279d6b80ebed829be7a804dde2">BUFFER_SIZE</a> &gt; &amp;buffer)&gt;</td></tr>
<tr class="separator:a1b95d6e95646af8502c81eb51ea1f232"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89734c342cac0f428c4653c656821636"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a89734c342cac0f428c4653c656821636">allocateAddress</a> ()=0</td></tr>
<tr class="separator:a89734c342cac0f428c4653c656821636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f67960f0c55270475b5995e9ecb9e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a76f67960f0c55270475b5995e9ecb9e8">registerReceiver</a> (<a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;receiver)=0</td></tr>
<tr class="separator:a76f67960f0c55270475b5995e9ecb9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25108bca10e81b195a42266f2c1a5bd2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a25108bca10e81b195a42266f2c1a5bd2">registerMulticastReceiver</a> (<a class="el" href="classoscar_1_1TransportMulticastReceiver.html">TransportMulticastReceiver</a>&lt; Self &gt; &amp;receiver)=0</td></tr>
<tr class="separator:a25108bca10e81b195a42266f2c1a5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb5fc411813a63a08bcd0725682a0b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a4bb5fc411813a63a08bcd0725682a0b7">scheduleTimeout</a> (std::chrono::microseconds delay, <a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a> callback)=0</td></tr>
<tr class="separator:a4bb5fc411813a63a08bcd0725682a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe4e9d8c5c75d92a6e0d4537c7a8bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#abdfe4e9d8c5c75d92a6e0d4537c7a8bc">scheduleSequential</a> (<a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a> callback)</td></tr>
<tr class="separator:abdfe4e9d8c5c75d92a6e0d4537c7a8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb0a793c8df60862c9506aed5f7880d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a3cb0a793c8df60862c9506aed5f7880d">scheduleConcurrent</a> (<a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a> callback)=0</td></tr>
<tr class="separator:a3cb0a793c8df60862c9506aed5f7880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a1bffd0639aedd276a53be28b9fde3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a80a1bffd0639aedd276a53be28b9fde3">getConcurrentId</a> () const =0</td></tr>
<tr class="separator:a80a1bffd0639aedd276a53be28b9fde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428461e07c001528d167a143d0aaed79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a428461e07c001528d167a143d0aaed79">sendMessage</a> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, const <a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a> &amp;dest, <a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a> write)=0</td></tr>
<tr class="separator:a428461e07c001528d167a143d0aaed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1017301869d80c4bd267ab777da7fbd7"><td class="memItemLeft" align="right" valign="top"><a id="a1017301869d80c4bd267ab777da7fbd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sendMessageToReplica</b> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, ReplicaId replica_id, <a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a> write)</td></tr>
<tr class="separator:a1017301869d80c4bd267ab777da7fbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266d9f88b4ba748bdb8fd8c3640791c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a266d9f88b4ba748bdb8fd8c3640791c3">sendMessageToAll</a> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, <a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a> write)</td></tr>
<tr class="separator:a266d9f88b4ba748bdb8fd8c3640791c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa978c50d0d83ec0a61f80e1b5f09071c"><td class="memItemLeft" align="right" valign="top"><a id="aa978c50d0d83ec0a61f80e1b5f09071c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>sendMessageToMulticast</b> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, <a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a> write)</td></tr>
<tr class="separator:aa978c50d0d83ec0a61f80e1b5f09071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7d3a3a71db9e796d43f4001b419e83c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt; Self &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a7d3a3a71db9e796d43f4001b419e83c4">config</a></td></tr>
<tr class="separator:a7d3a3a71db9e796d43f4001b419e83c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a01c5fb279d6b80ebed829be7a804dde2"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a01c5fb279d6b80ebed829be7a804dde2">BUFFER_SIZE</a> = <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt;Self&gt;::BUFFER_SIZE</td></tr>
<tr class="separator:a01c5fb279d6b80ebed829be7a804dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac9a29eaa89638d455a7b6eeb2e0001c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#ac9a29eaa89638d455a7b6eeb2e0001c9">Transport</a> (const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt; Self &gt; &amp;<a class="el" href="classoscar_1_1Transport.html#a7d3a3a71db9e796d43f4001b419e83c4">config</a>)</td></tr>
<tr class="separator:ac9a29eaa89638d455a7b6eeb2e0001c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Self&gt;<br />
class oscar::Transport&lt; Self &gt;</h3>

<p>General supporting runtime for <code><a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a></code>, the sending half of the actor model (and more).</p>
<p>The base class takes curiously recurring template pattern. The subclass <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code> is passed as template argument to <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code>, as well as <code><a class="el" href="structoscar_1_1Config.html">Config</a></code>, <code><a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a></code>, etc.</p>
<p>Besides of all interfaces defined here, a <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code> implementation probably wants to provide a <code>run</code> method to start main loop. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00042">42</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1c8682bdba52d3903c24664c9574923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8682bdba52d3903c24664c9574923d">&#9670;&nbsp;</a></span>Address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a> =  typename <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt;Self&gt;::<a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value-semantic address type. Possible choices include plain string, <code>socketaddr_in</code>, or more customized ones. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00054">54</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>

</div>
</div>
<a id="a9f4d3f1692b57758c10763bea8a50a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4d3f1692b57758c10763bea8a50a04">&#9670;&nbsp;</a></span>Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>General task closure. Receiver can keep things inside it alive between working steps. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00075">75</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>

</div>
</div>
<a id="a1b95d6e95646af8502c81eb51ea1f232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b95d6e95646af8502c81eb51ea1f232">&#9670;&nbsp;</a></span>Write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a> =  std::function&lt;std::size_t(<a class="el" href="Type_8hpp.html#a8acb43b3e680d8f2df1b66ab53eb20af">Buffer</a>&lt;<a class="el" href="classoscar_1_1Transport.html#a01c5fb279d6b80ebed829be7a804dde2">BUFFER_SIZE</a>&gt; &amp;buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Argument for <code>sendMessage*</code> methods. The lambda should in-place serialize message into <code>buffer</code>, and return message length. The returned value must not exceed <code>BUFFER_SIZE</code>. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00123">123</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac9a29eaa89638d455a7b6eeb2e0001c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a29eaa89638d455a7b6eeb2e0001c9">&#9670;&nbsp;</a></span>Transport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoscar_1_1Transport.html">Transport</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct base class with global configuration. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00047">47</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;: <a class="code" href="classoscar_1_1Transport.html#a7d3a3a71db9e796d43f4001b419e83c4">config</a>(<a class="code" href="classoscar_1_1Transport.html#a7d3a3a71db9e796d43f4001b419e83c4">config</a>) {}</div>
<div class="ttc" id="aclassoscar_1_1Transport_html_a7d3a3a71db9e796d43f4001b419e83c4"><div class="ttname"><a href="classoscar_1_1Transport.html#a7d3a3a71db9e796d43f4001b419e83c4">oscar::Transport::config</a></div><div class="ttdeci">const Config&lt; Self &gt; &amp; config</div><div class="ttdef"><b>Definition:</b> <a href="Transport_8hpp_source.html#l00062">Transport.hpp:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a89734c342cac0f428c4653c656821636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89734c342cac0f428c4653c656821636">&#9670;&nbsp;</a></span>allocateAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a> allocateAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dynamically allocate free address, mainly for construct <code><a class="el" href="classoscar_1_1Client.html">Client</a></code>. </p>

</div>
</div>
<a id="a76f67960f0c55270475b5995e9ecb9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f67960f0c55270475b5995e9ecb9e8">&#9670;&nbsp;</a></span>registerReceiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void registerReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>receiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a receiver. The caller ensures that receiver's reference will be valid as long as message get received on receiver's address, which probably happens through the rest of <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code>'s lifetime. </p>

</div>
</div>
<a id="a25108bca10e81b195a42266f2c1a5bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25108bca10e81b195a42266f2c1a5bd2">&#9670;&nbsp;</a></span>registerMulticastReceiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void registerMulticastReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1TransportMulticastReceiver.html">TransportMulticastReceiver</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>receiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a receiver that listens to multicast messages. <a class="el" href="classoscar_1_1Transport.html">Transport</a> implementation may require receiver to call <code>registerReceiver</code> first. </p>

</div>
</div>
<a id="a4bb5fc411813a63a08bcd0725682a0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb5fc411813a63a08bcd0725682a0b7">&#9670;&nbsp;</a></span>scheduleTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void scheduleTimeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::microseconds&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedule a one-time timeout. <code>callback</code> will be called after <code>delay</code>, cannot be canceled.</p>
<p>Unlike receiving message, timeout is non-direction, i.e., does not have a <code>receiver</code>. The behavior depends on <code>callback</code>'s capturing.</p>
<p>Timeout's <code>callback</code> is always executed sequentially. </p>

</div>
</div>
<a id="abdfe4e9d8c5c75d92a6e0d4537c7a8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfe4e9d8c5c75d92a6e0d4537c7a8bc">&#9670;&nbsp;</a></span>scheduleSequential()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void scheduleSequential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedule a sequential task. Sequential task is promised to be executed one by one without concurrency, so different sequential tasks can share states without locking. However, it is not guaranteed that all sequential tasks will be executed by the same thread.</p>
<p>A default implementation is provided mainly for implying that timeout is sequential task by default, so there is no need for calling <code>scheduleSequential</code> inside timeout callback. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00095">95</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <a class="code" href="classoscar_1_1Transport.html#a4bb5fc411813a63a08bcd0725682a0b7">scheduleTimeout</a>(std::chrono::microseconds(0), callback);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    }</div>
<div class="ttc" id="aclassoscar_1_1Transport_html_a4bb5fc411813a63a08bcd0725682a0b7"><div class="ttname"><a href="classoscar_1_1Transport.html#a4bb5fc411813a63a08bcd0725682a0b7">oscar::Transport::scheduleTimeout</a></div><div class="ttdeci">virtual void scheduleTimeout(std::chrono::microseconds delay, Callback callback)=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3cb0a793c8df60862c9506aed5f7880d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb0a793c8df60862c9506aed5f7880d">&#9670;&nbsp;</a></span>scheduleConcurrent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void scheduleConcurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#a9f4d3f1692b57758c10763bea8a50a04">Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedule a concurrent task. Multiple concurrent tasks may be executed with temporal overlapping, so they would better to be stateless. </p>

</div>
</div>
<a id="a80a1bffd0639aedd276a53be28b9fde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a1bffd0639aedd276a53be28b9fde3">&#9670;&nbsp;</a></span>getConcurrentId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int getConcurrentId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Every concurrent task get assigned to a concurrent id, which can be queried by calling <code>getConcurrentId</code> during execution. Concurrent id is unsigned and bounded.</p>
<p><a class="el" href="classoscar_1_1Transport.html">Transport</a> implementation promise that all concurrent tasks that get assigned to the same concurrent id will be sequentially executed. So it is safe to reuse pre-allocated memory "slot" among those tasks.</p>
<p><a class="el" href="classoscar_1_1Transport.html">Transport</a> may set concurrent id to <code>-1</code> for sequential tasks, but it is encouraged to determine sequential tasks by themselves. </p>

</div>
</div>
<a id="a428461e07c001528d167a143d0aaed79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428461e07c001528d167a143d0aaed79">&#9670;&nbsp;</a></span>sendMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sendMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoscar_1_1Transport.html#a1c8682bdba52d3903c24664c9574923d">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a>&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a message. The first argument is probably <code>*this</code>.</p>
<p><a class="el" href="classoscar_1_1Transport.html">Transport</a> implementation promise not to access <code>write</code> after this method return, so the closure can capture references with no worry. </p>

</div>
</div>
<a id="a266d9f88b4ba748bdb8fd8c3640791c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266d9f88b4ba748bdb8fd8c3640791c3">&#9670;&nbsp;</a></span>sendMessageToAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sendMessageToAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#a1b95d6e95646af8502c81eb51ea1f232">Write</a>&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default implementation is mainly for illustration purpose. <a class="el" href="classoscar_1_1Transport.html">Transport</a> should provide a more efficient version that only serialize once. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00143">143</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> address : <a class="code" href="classoscar_1_1Transport.html#a7d3a3a71db9e796d43f4001b419e83c4">config</a>.replica_address_list) {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            <span class="keywordflow">if</span> (address != sender.address) {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                <a class="code" href="classoscar_1_1Transport.html#a428461e07c001528d167a143d0aaed79">sendMessage</a>(sender, address, write);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            }</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        }</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    }</div>
<div class="ttc" id="aclassoscar_1_1Transport_html_a428461e07c001528d167a143d0aaed79"><div class="ttname"><a href="classoscar_1_1Transport.html#a428461e07c001528d167a143d0aaed79">oscar::Transport::sendMessage</a></div><div class="ttdeci">virtual void sendMessage(const TransportReceiver&lt; Self &gt; &amp;sender, const Address &amp;dest, Write write)=0</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7d3a3a71db9e796d43f4001b419e83c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3a3a71db9e796d43f4001b419e83c4">&#9670;&nbsp;</a></span>config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt;Self&gt;&amp; config</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration for <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code> instance, along with all registered receivers. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00062">62</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>

</div>
</div>
<a id="a01c5fb279d6b80ebed829be7a804dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c5fb279d6b80ebed829be7a804dde2">&#9670;&nbsp;</a></span>BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t BUFFER_SIZE = <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt;Self&gt;::BUFFER_SIZE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The size of buffer of tx message. May be helpful in assertion. </p>

<p class="definition">Definition at line <a class="el" href="Transport_8hpp_source.html#l00118">118</a> of file <a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/<a class="el" href="Transport_8hpp_source.html">Transport.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>oscar</b></li><li class="navelem"><a class="el" href="classoscar_1_1Transport.html">Transport</a></li>
    <li class="footer">Generated on Sat Dec 25 2021 12:47:35 for Oscar by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
