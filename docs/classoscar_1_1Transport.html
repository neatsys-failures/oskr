<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Oscar: oscar::Transport&lt; Self &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="oscar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Oscar
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">High Performance Distributed</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classoscar_1_1Transport.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classoscar_1_1Transport-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">oscar::Transport&lt; Self &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Transport_8hpp_source.html">Transport.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for oscar::Transport&lt; Self &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classoscar_1_1Transport__coll__graph.svg" width="226" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aff91396b76146595e391b69f5e22b93e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#aff91396b76146595e391b69f5e22b93e">Address</a> = typename <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt; Self &gt;::<a class="el" href="classoscar_1_1Transport.html#aff91396b76146595e391b69f5e22b93e">Address</a></td></tr>
<tr class="separator:aff91396b76146595e391b69f5e22b93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d533e280f8ecbf3fcd4556ca4d1c96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a> = std::function&lt; void()&gt;</td></tr>
<tr class="separator:aa3d533e280f8ecbf3fcd4556ca4d1c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a11e02eceec229ca9da406625e319a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a6a11e02eceec229ca9da406625e319a7">Write</a> = std::function&lt; std::size_t(<a class="el" href="Type_8hpp.html#ad579d39e03ab201f4c20e80e3ee8f80b">Buffer</a>&lt; <a class="el" href="classoscar_1_1Transport.html#a3ec403efa69791443bcedbd76aed74fc">BUFFER_SIZE</a> &gt; &amp;buffer)&gt;</td></tr>
<tr class="separator:a6a11e02eceec229ca9da406625e319a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3d5558ee3d5b5b986b3fd7acfbb0f00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoscar_1_1Transport.html#aff91396b76146595e391b69f5e22b93e">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#ab3d5558ee3d5b5b986b3fd7acfbb0f00">allocateAddress</a> ()=0</td></tr>
<tr class="separator:ab3d5558ee3d5b5b986b3fd7acfbb0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cef04d770422df78860c682c0278c6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a6cef04d770422df78860c682c0278c6e">registerReceiver</a> (<a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;receiver)=0</td></tr>
<tr class="separator:a6cef04d770422df78860c682c0278c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af731a2d5e477c570490d011b693cb5de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#af731a2d5e477c570490d011b693cb5de">registerMulticastReceiver</a> (<a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;receiver)=0</td></tr>
<tr class="separator:af731a2d5e477c570490d011b693cb5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3190e3914566e3d9726b36fb79d359a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#ad3190e3914566e3d9726b36fb79d359a">scheduleTimeout</a> (std::chrono::microseconds delay, <a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a> callback)=0</td></tr>
<tr class="separator:ad3190e3914566e3d9726b36fb79d359a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada764acb3c30c90bb50dba06a8318f1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#ada764acb3c30c90bb50dba06a8318f1e">scheduleSequential</a> (<a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a> callback)</td></tr>
<tr class="separator:ada764acb3c30c90bb50dba06a8318f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfd2706eac30831cd312869b1490bee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a1bfd2706eac30831cd312869b1490bee">scheduleConcurrent</a> (<a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a> callback)=0</td></tr>
<tr class="separator:a1bfd2706eac30831cd312869b1490bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd8e5bd990724c95ea591450c09f14e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a8bd8e5bd990724c95ea591450c09f14e">getConcurrentId</a> () const =0</td></tr>
<tr class="separator:a8bd8e5bd990724c95ea591450c09f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5e8804ec663f74387ad2eb167d8d60"><td class="memItemLeft" align="right" valign="top"><a id="acd5e8804ec663f74387ad2eb167d8d60"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>sendMessage</b> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, const <a class="el" href="classoscar_1_1Transport.html#aff91396b76146595e391b69f5e22b93e">Address</a> &amp;dest, <a class="el" href="classoscar_1_1Transport.html#a6a11e02eceec229ca9da406625e319a7">Write</a> write)=0</td></tr>
<tr class="separator:acd5e8804ec663f74387ad2eb167d8d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042e3921a049469877cf7e25f951ce43"><td class="memItemLeft" align="right" valign="top"><a id="a042e3921a049469877cf7e25f951ce43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sendMessageToReplica</b> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, ReplicaId replica_id, <a class="el" href="classoscar_1_1Transport.html#a6a11e02eceec229ca9da406625e319a7">Write</a> write)</td></tr>
<tr class="separator:a042e3921a049469877cf7e25f951ce43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c10c33c526f3626d04180aec1de4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#aa8c10c33c526f3626d04180aec1de4c4">sendMessageToAll</a> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, <a class="el" href="classoscar_1_1Transport.html#a6a11e02eceec229ca9da406625e319a7">Write</a> write)</td></tr>
<tr class="separator:aa8c10c33c526f3626d04180aec1de4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9cb8a32e5d007ad00a6fc3ad46af2b"><td class="memItemLeft" align="right" valign="top"><a id="a1b9cb8a32e5d007ad00a6fc3ad46af2b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>sendMessageToMulticast</b> (const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;sender, <a class="el" href="classoscar_1_1Transport.html#a6a11e02eceec229ca9da406625e319a7">Write</a> write)</td></tr>
<tr class="separator:a1b9cb8a32e5d007ad00a6fc3ad46af2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8b9ecf7c01c870e14abadf0c252b4a7e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt; Self &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a8b9ecf7c01c870e14abadf0c252b4a7e">config</a></td></tr>
<tr class="separator:a8b9ecf7c01c870e14abadf0c252b4a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3ec403efa69791443bcedbd76aed74fc"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#a3ec403efa69791443bcedbd76aed74fc">BUFFER_SIZE</a> = <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt;Self&gt;::BUFFER_SIZE</td></tr>
<tr class="separator:a3ec403efa69791443bcedbd76aed74fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad1a6c7d4d468f61851d7c480df858e5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoscar_1_1Transport.html#ad1a6c7d4d468f61851d7c480df858e5e">Transport</a> (const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt; Self &gt; &amp;<a class="el" href="classoscar_1_1Transport.html#a8b9ecf7c01c870e14abadf0c252b4a7e">config</a>)</td></tr>
<tr class="separator:ad1a6c7d4d468f61851d7c480df858e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Self&gt;<br />
class oscar::Transport&lt; Self &gt;</h3>

<p>General supporting runtime for <code><a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a></code>, the sending half of the actor model (and more).</p>
<p>The base class takes curiously recurring template pattern. The subclass <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code> is passed as template argument to <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code>, as well as <code><a class="el" href="structoscar_1_1Config.html">Config</a></code>, <code><a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a></code>, etc.</p>
<p>Besides of all interfaces defined here, a <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code> implementation probably wants to provide a <code>run</code> method to start main loop. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aff91396b76146595e391b69f5e22b93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff91396b76146595e391b69f5e22b93e">&#9670;&nbsp;</a></span>Address</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::<a class="el" href="classoscar_1_1Transport.html#aff91396b76146595e391b69f5e22b93e">Address</a> =  typename <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt;Self&gt;::<a class="el" href="classoscar_1_1Transport.html#aff91396b76146595e391b69f5e22b93e">Address</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value-semantic address type. Possible choices include plain string, <code>socketaddr_in</code>, or more customized ones. </p>

</div>
</div>
<a id="aa3d533e280f8ecbf3fcd4556ca4d1c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d533e280f8ecbf3fcd4556ca4d1c96">&#9670;&nbsp;</a></span>Callback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::<a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>General task closure. Receiver can keep things inside it alive between working steps. </p>

</div>
</div>
<a id="a6a11e02eceec229ca9da406625e319a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a11e02eceec229ca9da406625e319a7">&#9670;&nbsp;</a></span>Write</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::<a class="el" href="classoscar_1_1Transport.html#a6a11e02eceec229ca9da406625e319a7">Write</a> =  std::function&lt;std::size_t(<a class="el" href="Type_8hpp.html#ad579d39e03ab201f4c20e80e3ee8f80b">Buffer</a>&lt;<a class="el" href="classoscar_1_1Transport.html#a3ec403efa69791443bcedbd76aed74fc">BUFFER_SIZE</a>&gt; &amp;buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Argument for <code>sendMessage*</code> methods. The lambda should in-place serialize message into <code>buffer</code>, and return message length. The returned value must not exceed <code>BUFFER_SIZE</code>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad1a6c7d4d468f61851d7c480df858e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a6c7d4d468f61851d7c480df858e5e">&#9670;&nbsp;</a></span>Transport()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::<a class="el" href="classoscar_1_1Transport.html">Transport</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct base class with global configuration. </p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;: <a class="code" href="classoscar_1_1Transport.html#a8b9ecf7c01c870e14abadf0c252b4a7e">config</a>(<a class="code" href="classoscar_1_1Transport.html#a8b9ecf7c01c870e14abadf0c252b4a7e">config</a>) {}</div>
<div class="ttc" id="aclassoscar_1_1Transport_html_a8b9ecf7c01c870e14abadf0c252b4a7e"><div class="ttname"><a href="classoscar_1_1Transport.html#a8b9ecf7c01c870e14abadf0c252b4a7e">oscar::Transport::config</a></div><div class="ttdeci">const Config&lt; Self &gt; &amp; config</div><div class="ttdef"><b>Definition:</b> Transport.hpp:59</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab3d5558ee3d5b5b986b3fd7acfbb0f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d5558ee3d5b5b986b3fd7acfbb0f00">&#9670;&nbsp;</a></span>allocateAddress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoscar_1_1Transport.html#aff91396b76146595e391b69f5e22b93e">Address</a> <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::allocateAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dynamically allocate free address, mainly for construct <code><a class="el" href="classoscar_1_1Client.html">Client</a></code>. </p>

<p>Implemented in <a class="el" href="classoscar_1_1SimulatedTransport.html#a8a91137243944fcb38ab609bae623cbe">oscar::SimulatedTransport</a>.</p>

</div>
</div>
<a id="a6cef04d770422df78860c682c0278c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cef04d770422df78860c682c0278c6e">&#9670;&nbsp;</a></span>registerReceiver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::registerReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>receiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a receiver. The caller ensures that receiver's reference will be valid as long as message get received on receiver's address, which probably happens through the rest of <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code>'s lifetime. </p>

<p>Implemented in <a class="el" href="classoscar_1_1SimulatedTransport.html#aeddcd1f72cf9f6de6db0f88ef54b2c46">oscar::SimulatedTransport</a>.</p>

</div>
</div>
<a id="af731a2d5e477c570490d011b693cb5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af731a2d5e477c570490d011b693cb5de">&#9670;&nbsp;</a></span>registerMulticastReceiver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::registerMulticastReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>receiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a receiver that listens to multicast messages. <a class="el" href="classoscar_1_1Transport.html">Transport</a> implementation may require receiver to call <code>registerReceiver</code> first. </p>

<p>Implemented in <a class="el" href="classoscar_1_1SimulatedTransport.html#a1616f614fb7ed58fbf7e26441b4ef4cf">oscar::SimulatedTransport</a>.</p>

</div>
</div>
<a id="ad3190e3914566e3d9726b36fb79d359a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3190e3914566e3d9726b36fb79d359a">&#9670;&nbsp;</a></span>scheduleTimeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::scheduleTimeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::microseconds&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedule a one-time timeout. <code>callback</code> will be called after <code>delay</code>, cannot be canceled.</p>
<p>Unlike receiving message, timeout is non-direction, i.e., does not have a <code>receiver</code>. The behavior depends on <code>callback</code>'s capturing.</p>
<p>Timeout's <code>callback</code> is always executed sequentially. </p>

<p>Implemented in <a class="el" href="classoscar_1_1SimulatedTransport.html#a77f0f7a8c93c467b36d07adda6d7cec7">oscar::SimulatedTransport</a>.</p>

</div>
</div>
<a id="ada764acb3c30c90bb50dba06a8318f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada764acb3c30c90bb50dba06a8318f1e">&#9670;&nbsp;</a></span>scheduleSequential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::scheduleSequential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedule a sequential task. Sequential task is promised to be executed one by one without concurrency, so different sequential tasks can share states without locking. However, it is not guaranteed that all sequential tasks will be executed by the same thread.</p>
<p>A default implementation is provided mainly for implying that timeout is sequential task by default, so there is no need for calling <code>scheduleSequential</code> inside timeout callback. </p>

<p>Reimplemented in <a class="el" href="classoscar_1_1SimulatedTransport.html#a8e0b4f1b213d603d93d379b6e978c27e">oscar::SimulatedTransport</a>.</p>
<div class="fragment"><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <a class="code" href="classoscar_1_1Transport.html#ad3190e3914566e3d9726b36fb79d359a">scheduleTimeout</a>(std::chrono::microseconds(0), callback);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    }</div>
<div class="ttc" id="aclassoscar_1_1Transport_html_ad3190e3914566e3d9726b36fb79d359a"><div class="ttname"><a href="classoscar_1_1Transport.html#ad3190e3914566e3d9726b36fb79d359a">oscar::Transport::scheduleTimeout</a></div><div class="ttdeci">virtual void scheduleTimeout(std::chrono::microseconds delay, Callback callback)=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bfd2706eac30831cd312869b1490bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfd2706eac30831cd312869b1490bee">&#9670;&nbsp;</a></span>scheduleConcurrent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::scheduleConcurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#aa3d533e280f8ecbf3fcd4556ca4d1c96">Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Schedule a concurrent task. Multiple concurrent tasks may be executed with temporal overlapping, so they would better to be stateless. </p>

<p>Implemented in <a class="el" href="classoscar_1_1SimulatedTransport.html#ad2b031b4b5db0f9f6c9e077b8aa9f045">oscar::SimulatedTransport</a>.</p>

</div>
</div>
<a id="a8bd8e5bd990724c95ea591450c09f14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd8e5bd990724c95ea591450c09f14e">&#9670;&nbsp;</a></span>getConcurrentId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::getConcurrentId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Every concurrent task get assigned to a concurrent id, which can be queried by calling <code>getConcurrentId</code> during execution. Concurrent id is unsigned and bounded.</p>
<p><a class="el" href="classoscar_1_1Transport.html">Transport</a> implementation promise that all concurrent tasks that get assigned to the same concurrent id will be sequentially executed. So it is safe to reuse pre-allocated memory "slot" among those tasks.</p>
<p><a class="el" href="classoscar_1_1Transport.html">Transport</a> may set concurrent id to <code>-1</code> for sequential tasks, but it is encouraged to determine sequential tasks by themselves. </p>

<p>Implemented in <a class="el" href="classoscar_1_1SimulatedTransport.html#a36c65db760fb9579088720254a150628">oscar::SimulatedTransport</a>.</p>

</div>
</div>
<a id="aa8c10c33c526f3626d04180aec1de4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c10c33c526f3626d04180aec1de4c4">&#9670;&nbsp;</a></span>sendMessageToAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::sendMessageToAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoscar_1_1TransportReceiver.html">TransportReceiver</a>&lt; Self &gt; &amp;&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoscar_1_1Transport.html#a6a11e02eceec229ca9da406625e319a7">Write</a>&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default implementation is mainly for illustration purpose. <a class="el" href="classoscar_1_1Transport.html">Transport</a> should provide a more efficient version that only serialize once. </p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> address : <a class="code" href="classoscar_1_1Transport.html#a8b9ecf7c01c870e14abadf0c252b4a7e">config</a>.replica_address_list) {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            <span class="keywordflow">if</span> (address != sender.address) {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                sendMessage(sender, address, write);</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            }</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b9ecf7c01c870e14abadf0c252b4a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9ecf7c01c870e14abadf0c252b4a7e">&#9670;&nbsp;</a></span>config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structoscar_1_1Config.html">Config</a>&lt;Self&gt;&amp; <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::config</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration for <code><a class="el" href="classoscar_1_1Transport.html">Transport</a></code> instance, along with all registered receivers. </p>

</div>
</div>
<a id="a3ec403efa69791443bcedbd76aed74fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec403efa69791443bcedbd76aed74fc">&#9670;&nbsp;</a></span>BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Self &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classoscar_1_1Transport.html">oscar::Transport</a>&lt; Self &gt;::BUFFER_SIZE = <a class="el" href="structoscar_1_1TransportMeta.html">TransportMeta</a>&lt;Self&gt;::BUFFER_SIZE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The size of buffer of tx message. May be helpful in assertion. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/<a class="el" href="Transport_8hpp_source.html">Transport.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>oscar</b></li><li class="navelem"><a class="el" href="classoscar_1_1Transport.html">Transport</a></li>
    <li class="footer">Generated on Thu Dec 23 2021 16:15:03 for Oscar by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
